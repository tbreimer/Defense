<!DOCTYPE HTML>
<html>
  <head>
    <title>Defense v2.0-Beta</title>
    <style>
      canvas {
		position: absolute;
		top: 0px;
		left: 0px;
	}
    </style>
  </head>
  <body onload="init()">
    <canvas id="worldLayer" width="1280" height="720"></canvas>
    <canvas id="bgLayer" width="1280" height="720"></canvas>
    <canvas id="playerLayer" width="1280" height="720"></canvas>
    <canvas id="additionLayer" width="1280" height="720"></canvas>
	<canvas id="uiLayer" width="1280" height="720" onmousemove="getMousePos(event)" onmousedown="mouseDown(event)" onmouseup="mouseUp(event)"></canvas>
<script src="js/jquery-3.2.1.min.js"></script>
<script src="js/entities.js"></script>
<script src="js/ui.js"></script>
<script>
	
// Canvas
var wCanvas = document.getElementById('worldLayer');
var wCtx = wCanvas.getContext("2d");
var bCanvas = document.getElementById('bgLayer');
var bCtx = bCanvas.getContext("2d");
var pCanvas = document.getElementById('playerLayer');
var pCtx = pCanvas.getContext("2d");
var aCanvas = document.getElementById('additionLayer');
var aCtx = aCanvas.getContext("2d");
var uCanvas = document.getElementById('uiLayer');
var uCtx = uCanvas.getContext("2d");
console.log("Canvas Created");

// Keys
document.body.addEventListener("keydown", keyDown, false);
document.body.addEventListener("keyup", keyUp, false);

// Create entities
var world = new World();

var player = new Player();

var ui = new UI();

// Database of blocks

// Name
var blockName = ["water", "grass", "sand", "bush", "rock"];

// Whether they have collision
var blockCollision = [true, false, false, false, true];

// Whether blocks have collision for entities
var blockCollisionEntities = [false, false, false, false, true];

// Color on map
var blockColor = [
	[255, 255, 255], // water
	[0, 255, 0], // grass
	[255, 255, 0], // sand
	[30, 100, 20], // bush
	[200, 200, 200] // rock
];

// Color in world, addition indicates special drawing instructions
var blockTextures = [
	[30, 115, 255], // water
	[45, 190, 40], // grass
	[255, 255, 0], // sand
	"addition", // bush
	"addition" // rock
];

// What number the block should have when it is created on the world.blockAttributes array
// Attribute refers to the number a block is assigned when it is created, attributes refers to the current number of a certain block
var blockAttribute = [0, 0, 0, 100, 0];

window.addEventListener('resize', resize);

function resize(){
	// Get window size
	windowWidth = window.innerWidth || document.body.clientWidth;
	windowHeight =  window.innerHeight || document.body.clientHeight;
	
	// Change canvas size to window size
	wCanvas.width = windowWidth; 
	bCanvas.width = windowWidth; 
	pCanvas.width = windowWidth;
	uCanvas.width = windowWidth;
	aCanvas.width = windowWidth;
	wCanvas.height = windowHeight;
	bCanvas.height = windowHeight;
	pCanvas.height = windowHeight;
	uCanvas.height = windowHeight;
	aCanvas.height = windowHeight;

	$("body").css("overflow", "hidden");

	// Ensures that world is rendered on the first frame and upon resize
	world.render();
}

// Variables to calculate fps
var fps;
var frame = 0;

// Every second this method is executed
function everySecond(){
	// Calculate fps
	fps = frame;
	frame = 0;

	world.updateAdditions();
}

// Triggered at a delay, after that delay interval is over so it restarts waves
function interval(){
	console.log("cchnage interval")
	world.interval = false;
}

// Find distance given width and height
function findDistance(width, height){
    total = width * width + height * height;
    return Math.sqrt(total);
}

// Get random, min inclusive and max exclusive
function getRandom(min, max) {
  return Math.random() * (max - min) + min;
}

// Happens when page loads
function init(){
	world.create();
	console.log("World Initialized")

	requestAnimationFrame(update);
	console.log("First Refresh");

	//Calculate fps
	setInterval(everySecond, 1000);

	resize();
}

function update(){
	frame += 1;

	world.update();

	//If player is alive, update them
	if (player.alive == true){
		player.update();
	}

	ui.update();

	requestAnimationFrame(update);
}

function World() {
	// 0: In game 1: Dead
	this.mode = 0;

	this.worldWidth = 50;
	this.worldHeight = 50;

	this.blockSize = 40;

	// Name of each block in world in 2d array
	this.blockData = [];

	// A number associated with each block in 2d array to hold some attribute about the block
	this.blockAttributes = [];

	this.entities = [];

	this.islandRadius = 15;

	// % Chance entity will spawn per aframe
	this.difficulty = 0.5;

	// How many entites spawn per wave and how many have spawned this wave
	this.entitiesPerWave = 20;
	this.entitiesSpawned = 0;

	// Wave number
	this.wave = 1;

	// How many waves in between each interval
	this.intervalNumber = 5;

	// How many frames in between each wave
	this.intervalTime = 120000;

	// How many frames have passed during current interval
	this.intervalFrames = 0; 

	// If interval is currently happenning
	this.interval = false;

	// How many more entities are spawned each wave
	this.increasePerWave = 5;

	// On which side entities are spawned (0: top, 1: bottom, 2: left, 3: right)
	this.spawnSide = 0;

	// If world is being rendered every frame, false if player is not moving
	this.updating = false; 

	World.prototype.update = function(){
		pCtx.clearRect(0, 0, windowWidth, windowHeight);
		uCtx.clearRect(0, 0, windowWidth, windowHeight);

		this.spawnEntities();

 		// Assures that world is only rendered when player is moving
 		if (player.movementU != false || player.movementD != false || player.movementL != false || player.movementR != false){
			this.render();
 		}

 		// Updates all entities
 		for (var x = 0; x < this.entities.length; x++){
 			// Only update if entity is alive
 			if (this.entities[x].alive == true){
 				this.entities[x].update();
 			}
 		}
	}

	// Methods that render the world ----------

	World.prototype.render = function(){
		// Ensures the screen is only cleared before the canvas updates
		bCtx.clearRect(0, 0, windowWidth, windowHeight);
		aCtx.clearRect(0, 0, windowWidth, windowHeight);

		// Render world

		// Water background
 		bCtx.fillStyle = "rgb(30, 115, 255)";
 		bCtx.fillRect(0, 0, windowWidth, windowHeight);

 		// Gets coordinates of the top left of the canvas
 		topX = Math.round(player.x - (windowWidth / 2));
 		topY = Math.round(player.y - (windowHeight / 2));

 		// Finds the top left block closest to the top left of the canvas
 		topBlockX = Math.floor(topX / this.blockSize);
 		topBlockY = Math.floor(topY / this.blockSize);

 		// Gets that block's coordinates
 		topBlockCoordX = topBlockX * this.blockSize;
 		topBlockCoordY = topBlockY * this.blockSize;

 		// Finds offset from top left of canvas to the block's coordinates
 		offsetX = topX - topBlockCoordX;
 		offsetY = topY - topBlockCoordY;

 		// Gets the number of blocks in the canvas
 		blockWidth = Math.ceil(windowWidth / this.blockSize) + 1;
 		blockHeight = Math.ceil(windowHeight / this.blockSize) + 1;

 		// Loop through all the blocks that need to be drawn
 		for (var x = 0; x < blockWidth; x++){
 			for (var y = 0; y < blockHeight; y++){

 				// Ensures that blocks not in the array will not be drawn
 				if (topBlockX + x >= 0 && topBlockX + x < this.worldWidth && topBlockY + y >= 0 && topBlockY + y < this.worldWidth){

 					// Ensures that water is not drawn
 					if (this.blockData[topBlockX + x][topBlockY + y] != "water"){

 						// Gets the color of block from its name
	 					colorData = this.getBlockTexture(this.blockData[topBlockX + x][topBlockY + y]);

	 					blockX = Math.floor(x * this.blockSize - offsetX);
	 					blockY = Math.floor(y * this.blockSize - offsetY);

	 					// If block is addition and requires special drawing instructions
	 					if (colorData == "addition"){
	 						this.drawAddition(this.blockData[topBlockX + x][topBlockY + y], blockX, blockY, this.blockAttributes[topBlockX + x][topBlockY + y], topBlockX + x, topBlockY + y);
	 					}else{
	 						// Draw block
			 				bCtx.fillStyle = "rgb(" + colorData.r + "," + colorData.g + "," + colorData.b + ")";
			 				bCtx.fillRect(blockX, blockY, this.blockSize, this.blockSize);

			 				// Stroke block
			 				bCtx.lineWidth = 2;
			 				bCtx.fillStyle = "black";
			 				bCtx.strokeRect(blockX, blockY, this.blockSize, this.blockSize);
	 					}
		 			}
 				}

 			}
 		}
	}

	World.prototype.drawAddition = function(addition, blockX, blockY, attributes, x, y){
		// Triggered by renderer, draws specific additions given the coords of the block they need to be draw on
		// blockX and blockY are where the addition needs to be draw, x and y are the block's coords in the array

		// Draw grass block behind addition
		colorData = this.getBlockTexture("grass");
		bCtx.fillStyle = "rgb(" + colorData.r + "," + colorData.g + "," + colorData.b + ")";
		bCtx.fillRect(blockX, blockY, this.blockSize, this.blockSize);

		// Stroke block
		bCtx.lineWidth = 2;
		bCtx.fillStyle = "black";
		bCtx.strokeRect(blockX, blockY, this.blockSize, this.blockSize);

		if (addition == "bush"){
			// In the world.blockAttributes array, each bush has a value from 0 - 100 
			// which represents its radius and therefore how much material can be harvested from it

			// Gets proportion
			largestRadius = this.blockSize / 2 - 3;
			factor = largestRadius / blockAttribute[3];

			centerX = blockX + this.blockSize / 2;
			centerY = blockY + this.blockSize / 2;
			radius = Math.floor(factor * attributes);

      		// Fill and stroke
			aCtx.beginPath();
      		aCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
      		aCtx.fillStyle = 'green';
      		aCtx.fill();
      		aCtx.lineWidth = 2;
      		aCtx.strokeStyle = 'black';
      		aCtx.stroke();

		}else if (addition == "rock"){

			centerX = blockX + this.blockSize / 2;
			centerY = blockY + this.blockSize / 2;
			radius = this.blockSize / 2 - 3;

      		// Fill and stroke
			bCtx.beginPath();
      		bCtx.arc(centerX, centerY, radius, 0, 2 * Math.PI, false);
      		bCtx.fillStyle = 'gray';
      		bCtx.fill();
      		bCtx.lineWidth = 2;
      		bCtx.strokeStyle = 'black';
      		bCtx.stroke();
		}
	}

	// Methods that initialize the world ----------

	World.prototype.create = function(){
		// Erase current world
		wCtx.fillStyle = "white";
		wCtx.fillRect(0, 0, this.worldWidth, this.worldHeight);

		// Sand background

		// Loops through all the blocks
		for (var x = 0; x < this.worldWidth; x++){
 			for (var y = 0; y < this.worldHeight; y++){
 				// Find center of world
 				centerX = this.worldWidth / 2;
 				centerY = this.worldHeight / 2;

 				// Coord distance from center to current block
 				width = centerX - x;
 				height = centerY - y;

 				// Distance from center to current block
 				distance = findDistance(width, height);

 				// If block is less than island width (plus a little more for the sand to show) draw a block
 				if (distance < this.islandRadius + 1.5){
 					wCtx.fillStyle = 'rgb(255, 255, 0)';
 					wCtx.fillRect(x, y, 1, 1);
 				}
 				
 			}
 		}

 		// Grass background

 		for (var x = 0; x < this.worldWidth; x++){
 			for (var y = 0; y < this.worldHeight; y++){
 				centerX = this.worldWidth / 2;
 				centerY = this.worldHeight / 2;

 				width = centerX - x;
 				height = centerY - y;

 				distance = findDistance(width, height);
 				
 				if (distance < this.islandRadius){
 					wCtx.fillStyle = 'rgb(0, 255, 0)';
 					wCtx.fillRect(x, y, 1, 1);
 				}
 			}
 		}

 		// Addition spawning

 		// Loop through all the blocks
 		for (var x = 0; x < this.worldWidth; x++){
 			for (var y = 0; y < this.worldHeight; y++){

 				// Check if current block is grass
 				if (this.determineBlock(x, y) == "grass"){

 					// 5 Percent chance bush is spawned on grass and 5 percent chance rock is spawned
 					rand = getRandom(0, 100);

	 				if (rand < 5){
	 					// Make bush
	 					wCtx.fillStyle = 'rgb(30, 100, 20)';
 						wCtx.fillRect(x, y, 1, 1);
	 				}else if (rand < 10){
	 					// Make rock
	 					wCtx.fillStyle = 'rgb(200, 200, 200)';
 						wCtx.fillRect(x, y, 1, 1);
	 				}
 				}
 			}
 		}

 		// Transcribe world onto array
 		world.transcribe();
	}

	World.prototype.transcribe = function(){
		// Transcibes pixels that makeup world onto an array
		for (var x = 0; x < this.worldWidth; x++){

			// Is added onto 2d array
			rowArray = [];

			for (var y = 0; y < this.worldHeight; y++){
				blockType = this.determineBlock(x, y);
				rowArray.push(blockType);
			}

			this.blockData.push(rowArray);
		}

		// Intialize block attribute data

		// Loops through all the blocks
		for (var x = 0; x < this.worldWidth; x++){

			// Is added onto 2d array
			rowArray = [];

 			for (var y = 0; y < this.worldHeight; y++){
 				blockType = this.determineBlock(x, y);
 				rowArray.push(this.getBlockAttribute(blockType));
 			}

 			this.blockAttributes.push(rowArray);
 		}
	}

	// Other methods ----------

	World.prototype.updateAdditions = function(){
		// Triggered every second, updates all additions in world

		// Loops through all the blocks
		for (var x = 0; x < this.worldWidth; x++){
 			for (var y = 0; y < this.worldHeight; y++){
 				// Determine if block is addition
	 			colorData = this.getBlockTexture(this.blockData[x][y]);

	 			// If block is a bush
	 			if (this.blockData[x][y] == "bush"){

	 				// If bush is less then maximum size, grow it
	 				if (blockAttribute[3] > this.blockAttributes[x][y]){
	 					this.blockAttributes[x][y] += 0.5;
	 				}
	 			}

 			}
 		}

 		world.render();
	}

	World.prototype.spawnEntities = function(){
		// Triggered every frame

		// Increases difficulty over time
		this.difficulty += 0.0001;

		// Randomly spawn entities
		random = Math.random() * 100;

		// If random occurs and a wave is currently hapenning
		if (random < this.difficulty && this.interval == false){
			// Get coordinates from the correct side
			if (this.spawnSide == 0){
				x = getRandom(0, this.worldWidth * this.blockSize);
				y = 0 + (getRandom(-3, 3) * world.blockSize);
			}else if(this.spawnSide == 1){
				x = getRandom(0, this.worldWidth * this.blockSize);
				y = (this.worldHeight * this.blockSize) + (getRandom(-3, 3) * world.blockSize);
			}else if(this.spawnSide == 2){
				x = 0 + (getRandom(-3, 3) * world.blockSize);;
				y = getRandom(0, this.worldWidth * this.blockSize);
			}else{
				x = (this.worldWidth * this.blockSize) + (getRandom(-3, 3) * world.blockSize);
				y = getRandom(0, this.worldWidth * this.blockSize);
			}

			this.entities.push(new Entity(x, y, this.entities.length));
			this.entitiesSpawned += 1;
		}

		// If enough enemies have been spawned to change to the next wave
		if (this.entitiesSpawned >= this.entitiesPerWave){

			// Check if interval should happen
			if (this.wave % this.intervalNumber == 0){
				this.wave += 1;
				this.interval = true;

				this.entitiesSpawned = 0;
				this.entitiesPerWave += this.increasePerWave;

			}else if (this.interval == false){
				// Reset for next wave
				this.entitiesSpawned = 0;
				this.entitiesPerWave += this.increasePerWave;

				this.spawnSide = Math.floor(getRandom(0, 4));

				this.wave += 1;

			}
		}

		// If interval is happening, increase the amount of frames that have happened since interval was triggered
		if (this.interval == true){
			this.intervalFrames += 1;
		}

		// If the number of frames since the interval has been triggered is more than the amount of frames per interval, restart the waves
		if (this.intervalFrames >= this.intervalTime){
			this.interval = false;
			this.intervalFrames = 0;
		}
	}

	World.prototype.collectMaterial = function(x, y){
		// Collect material from block specified in coords

		// Prevent error from trying to access array out of bounds

		if (x >= 0 && x < this.worldWidth && y >= 0 && y < this.worldWidth){

			if (this.blockData[x][y] == "bush"){

				// decrease its size
				this.blockAttributes[x][y] -= 1;

				// If bush is less than minimum size, replace it with a grass block
				if (this.blockAttributes[x][y] < (blockAttribute[3] / 4)){
					this.blockData[x][y] = "grass";
					player.saplings += 1;

				}else{
					// Else increase the player's material (to prevent player from being able to infinitely increase material)
					player.material += 1;
				}
			}

			this.render();
		}
	}

	World.prototype.createAddition = function(x, y, additionName, attribute){
		// Returns true if addition could be created, false if it could not

		if (this.blockData[x][y] == "grass"){ // Additions can only be put on grass
			this.blockData[x][y] = additionName;
			this.blockAttributes[x][y] = attribute;

			this.render();

			return true;
		}else{
			return false;
		}
	}

	// Methods to determine attributes of blocks ----------

	World.prototype.determineBlock = function(x, y){
		// Determine block name via coordinates through the map

		block = wCtx.getImageData(x, y, 1, 1).data;
		
		// Loops through all the blocks and finds a matching one
		for (var x = 0; x < blockName.length; x++){ 
			if (block[0] == blockColor[x][0] && block[1] == blockColor[x][1] && block[2] == blockColor[x][2]){
				return blockName[x];
			}
		}

		// If block cannot be identified
		return "water";
	}

	World.prototype.determineBlockCollision = function(x, y){
		// Determine collision via coordinates through the world array
		if (x >= 0 && x < this.worldWidth && y >= 0 && y < this.worldWidth){
			block = world.blockData[x][y];

			index = blockName.indexOf(block);

			return blockCollision[index];
		}else{
			// If block is not in array, therefore water
			return true;
		}
	}

	World.prototype.determineEntityBlockCollision = function(x, y){
		// Determine collision for entitiesa via coordinates through the world array
		if (x >= 0 && x < this.worldWidth && y >= 0 && y < this.worldWidth){
			block = world.blockData[x][y];

			index = blockName.indexOf(block);

			return blockCollisionEntities[index];
		}else{
			// If block is not in array, therefore water
			return false;
		}
	}

	World.prototype.getBlockAttribute = function(block){
		// Gets the starting attribute of a certain block
		for (var x = 0; x < blockName.length; x++){
			if (block == blockName[x]){
				return blockAttribute[x];
			}
		}

		return 0;
	}

	World.prototype.getBlockTexture = function(block){
		// Determine block texture via block name

		for (var x = 0; x < blockName.length; x++){
			if (block == blockName[x]){
				// Determine if block needs special drawing instructions or is just a color
				if (Array.isArray(blockTextures[x]) == false){
					return blockTextures[x];
				}else{
					return{
						r: blockTextures[x][0],
						g: blockTextures[x][1],
						b: blockTextures[x][2]
					}  
				}
			}
		}
	}
}

function Player(){
	this.health = 100;
	this.alive = true;
	this.maxHealth = 100;

	this.score = 0;

	this.material = 0;

	// Center player on island 
	this.x = world.blockSize * (world.worldWidth / 2);
	this.y = world.blockSize * (world.worldHeight / 2);

	this.screenX;
	this.screenY;

	this.width = 30
	this.height = 30;

	this.movementU = false;
	this.movementD = false;
	this.movementL = false;
	this.movementR = false;

	this.deltaU = 0;
	this.deltaD = 0;
	this.deltaL = 0;
	this.deltaR = 0;

	this.speed = 4;

	this.damage = 10;
	this.reach = 150; // Max distance between player and enemy, and mouse and enemy to attack

	this.coolInterval = 20; // How many frames it takes for weapon to cool down
	this.coolDown = 20; // How many frames since weapon was last used, stopped when it is the same as cool interval

	this.saplings = 0; // How many saplings the player has

	// What the player is selecting 0: Collector 1: Sword 2: Saplings
	this.selection = 0;

	Player.prototype.update = function(){
		// Check if health is too low
		if (this.health <= 0){
			this.alive = false;
			world.mode = 1;
		}

		this.movement();

		// Check if player pressed mouse, what is done depends on what is selected
		if (ui.mousePressed == true){

			if (this.selection == 0){ // Collect material
				world.collectMaterial(ui.mouseBx, ui.mouseBy);
			}

			if (this.selection == 2 && this.saplings > 0){
				var placed = world.createAddition(ui.mouseBx, ui.mouseBy, "bush", (blockAttribute[3] / 4)); // Create sapling

				if (placed == true){
					// Sapling was placed, remove one from inventory
					this.saplings -= 1;
				}
			}
		}

		// Fires for one frame as soon as player presses mouse, what is done depends on what is selected
		if (ui.press == true){
			if (this.selection == 1){
				this.attack(); // Use sword
			}
			
		}

		// Increases number of frames since player last attacked, stopped when it equals cool interval
		if (this.coolDown < this.coolInterval){
			this.coolDown += 1;
		}
		
		// Draw player
		this.screenX = Math.floor((windowWidth / 2) - (this.width / 2));
		this.screenY = Math.floor((windowHeight / 2) - (this.height / 2));
		
		pCtx.fillStyle = "blue";
		pCtx.fillRect(this.screenX, this.screenY, this.width, this.height);

		pCtx.strokeStyle = "black";
		pCtx.lineWidth = 2;
		pCtx.strokeRect(this.screenX, this.screenY, this.width, this.height);
	}
	Player.prototype.movement = function(){

		// Handles diagonal movement

		this.deltaU = 0;
		this.deltaD = 0;
		this.deltaL = 0;
		this.deltaR = 0;

		if (this.movementU == true){
			if (this.movementL == true){
				this.deltaU = this.speed * 0.75;
				this.deltaL = this.speed * 0.75;
			}else if (this.movementR == true){
				this.deltaU = this.speed * 0.75;
				this.deltaR = this.speed * 0.75;
			}else{
				this.deltaU = this.speed;
			}
		}

		if (this.movementD == true){
			if (this.movementL == true){
				this.deltaD = this.speed * 0.75;
				this.deltaL = this.speed * 0.75;
			}else if (this.movementR == true){
				this.deltaD = this.speed * 0.75;
				this.deltaR = this.speed * 0.75;
			}else{
				this.deltaD = this.speed;
			}
		}

		// No need to cover diagonal movement here since all 4 diagonal directions are already accounted for 
		if (this.movementL == true && this.movementU == false && this.movementD == false){
			this.deltaL = this.speed;
		}

		if (this.movementR == true && this.movementU == false && this.movementD == false){
			this.deltaR = this.speed;
		}

		// Collision detection

		// Gets x and y of top of player
		topX = this.x - (this.width / 2);
		topY = this.y - (this.height / 2);

		// Finds x and y of bottom of player
		bottomX = this.x + (this.width / 2);
		bottomY = this.y + (this.height / 2);

		// Finds how many blocks the player spans in current position
		blockWidth = Math.floor(bottomX / world.blockSize) - Math.floor(topX / world.blockSize) + 1;
		blockHeight = Math.floor(bottomY / world.blockSize) - Math.floor(topY / world.blockSize) + 1;
		
		//If there is a block with collision to the left
		blockL = false

		// Collision left
		// If the player will pass a block next frame
		if (Math.floor(topX / world.blockSize) != Math.floor((topX - this.deltaL) / world.blockSize)){
			// Go through all the blocks adjacent to the player's left
			for (var x = 0; x < blockHeight; x ++){
				blockX = Math.floor((topX - this.deltaL) / world.blockSize);
				blockY = Math.floor(topY / world.blockSize) + x;
				// Find if the block has collision
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockL = true; 
				}
			}
		}

		// Collision right
		blockR = false
		if (Math.floor(bottomX / world.blockSize) != Math.floor((bottomX + this.deltaR) / world.blockSize)){
			for (var x = 0; x < blockHeight; x ++){
				blockX = Math.floor((bottomX + this.deltaR) / world.blockSize);
				blockY = Math.floor(topY / world.blockSize) + x;
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockR = true; 
				}
			}
		}

		// Collision Up
		blockU = false
		if (Math.floor(topY / world.blockSize) != Math.floor((topY - this.deltaU) / world.blockSize)){
			for (var x = 0; x < blockWidth; x ++){
				blockY = Math.floor((topY - this.deltaU) / world.blockSize);
				blockX = Math.floor(topX / world.blockSize) + x;
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockU = true; 
				}
			}
		}

		// Collision Down
		blockD = false
		if (Math.floor(bottomY / world.blockSize) != Math.floor((bottomY + this.deltaD) / world.blockSize)){
			for (var x = 0; x < blockWidth; x ++){
				blockY = Math.floor((bottomY + this.deltaD) / world.blockSize);
				blockX = Math.floor(topX / world.blockSize) + x;
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockD = true; 
				}
			}
		}

		// Collision diagonal

		// Collision top left
		// Only do collision is player is going diagonally (prevents bug)
		if (blockU == false && blockL == false){
			// Check if player will be in a diagonal block next frame
			if (Math.floor(topY / world.blockSize) != Math.floor((topY - this.deltaU) / world.blockSize) && Math.floor(topX / world.blockSize) != Math.floor((topX - this.deltaL) / world.blockSize)){
				// Find that diagonal block
				blockY = Math.floor((topY - this.deltaU) / world.blockSize);
				blockX = Math.floor((topX - this.deltaL) / world.blockSize);
				// Test if that diagonal block has collision
				if (world.determineBlockCollision(blockX, blockY) == true){
					// Ensures player does not come to a complete stop when hitting a block from 
					blockU = true;
				}
			}
		}

		// Collision bottom left
		if (blockD == false && blockL == false){
			if (Math.floor(bottomY / world.blockSize) != Math.floor((bottomY + this.deltaD) / world.blockSize) && Math.floor(topX / world.blockSize) != Math.floor((topX - this.deltaL) / world.blockSize)){
				blockY = Math.floor((bottomY + this.deltaD) / world.blockSize);
				blockX = Math.floor((topX - this.deltaL) / world.blockSize);
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockD = true;
				}
			}
		}

		// Collision bottom right
		if (blockD == false && blockR == false){
			if (Math.floor(bottomY / world.blockSize) != Math.floor((bottomY + this.deltaD) / world.blockSize) && Math.floor(topX / world.blockSize) != Math.floor((bottomX + this.deltaR) / world.blockSize)){
				blockY = Math.floor((bottomY + this.deltaD) / world.blockSize);
				blockX = Math.floor((bottomX + this.deltaR) / world.blockSize);
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockD = true;
				}
			}
		}

		// Collision top right
		if (blockU == false && blockR == false){
			if (Math.floor(bottomY / world.blockSize) != Math.floor((topY - this.deltaU) / world.blockSize) && Math.floor(topX / world.blockSize) != Math.floor((bottomX + this.deltaR) / world.blockSize)){
				blockY = Math.floor((topY - this.deltaU) / world.blockSize);
				blockX = Math.floor((bottomX + this.deltaR) / world.blockSize);
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockU = true;
				}
			}
		}

		// If no block is in the way, change the coordinates

		if (blockR == false){
			this.x += this.deltaR;
		}

		if (blockL == false){
			this.x -= this.deltaL;
		}
		
		if (blockD == false){
			this.y += this.deltaD;
		}
	
		if (blockU == false){
			this.y -= this.deltaU;
		}
	}
	Player.prototype.respawn = function(){
		world.mode = 0;
		world.entities = [];

		this.health = 100;
		this.alive = true;
		this.maxHealth = 100;

		this.score = 0;

		// Center player on island 
		this.x = world.blockSize * (world.worldWidth / 2);
		this.y = world.blockSize * (world.worldHeight / 2);

		this.damage = 10;

		// Update changes
		world.render();
	}
	Player.prototype.attack = function(){

		// Divide to find % amount cool down, damage factor is 1 if fully cooled down
		damageFactor = this.coolDown / this.coolInterval;
		
		// Reset frames since weapon used
		this.coolDown = 0;

		damage = this.damage * damageFactor;

		// Used to find closest enemy to mouse
		var closestID = -1;
		var closestPix = this.reach;
		var dist;

		// Loops through all entities
		for (var x = 0; x < world.entities.length; x++){
			// Ensures dead entities aren't counted
			if (world.entities[x].alive == true){
				entity = world.entities[x];
				mouseDist = findDistance((entity.screenX + entity.width / 2) - ui.mouseX, (entity.screenY + entity.height / 2) - ui.mouseY);
				playerDist = findDistance(entity.x - player.x, entity.y - player.y);
				
				// If enemy is close to player and closer to the mouse than any other enemy from beofre
				if (mouseDist < closestPix && playerDist < this.reach){
					closestID = x;
					closestPix = mouseDist;
					dist = playerDist;
				}
			}
		}

		// Damage enemy that is within reach by player and mouse, and is closest to mouse
		if (closestID != -1){
			world.entities[closestID].damage(damage);
		}
	}
}

function keyDown(evt){
  evt.preventDefault();
  set(evt.keyCode);
	evt.stopPropagation();
	return;
}

function keyUp(evt){
  evt.preventDefault();
  unSet(evt.keyCode);
	evt.stopPropagation();
	return;
}

function set(key){
	// W
	if(key == 87){
		player.movementU = true;
	}
	// A
	if(key == 65){
		player.movementL = true;
	}
	// S
	if(key == 83){
		player.movementD = true;
	}
	// D
	if(key == 68){
		player.movementR = true;
	}

	// Change item selected

	// 1
	if (key == 49){
		player.selection = 0; // Collector
	}
	// 2
	if (key == 50){
		player.selection = 1; // Sword
	}
	// 3
	if (key == 51){
		player.selection = 2; // Sapling
	}
}

function unSet(key){
	// W
	if(key == 87){
		player.movementU = false;
	}
	// A
	if(key == 65){
		player.movementL = false;
	}
	// Scontains
	if(key == 83){
		player.movementD = false;
	}
	// D
	if(key == 68){
		player.movementR = false;
	}

	// Causes the world to be rendered at the resting state of movement, which prevents jittery-ness when player moves again
	world.render();
}

// Mouse 

function getMousePos(evt) {
	var rect = bCanvas.getBoundingClientRect();

	ui.mouseX = evt.clientX - rect.left;
	ui.mouseY = evt.clientY - rect.top;

}

// Mouse clicked event listeners

function mouseDown(evt){
	ui.mousePressed = true;
	ui.press = true; // Will be true for one frame
}
function mouseUp(evt){
	ui.mousePressed = false;
	ui.click = true; // Will be true for one frame
}


  
    </script>
  </body>
</html>
