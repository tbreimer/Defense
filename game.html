<!DOCTYPE HTML>
<html>
  <head>
    <title>Defense</title>
    <style>
      canvas {
		position: absolute;
		top: 0px;
		left: 0px;
	}
    </style>
  </head>
  <body onload="init()">
    <canvas id="worldLayer" width="1280" height="720"></canvas>
    <canvas id="bgLayer" width="1280" height="720"></canvas>
    <canvas id="playerLayer" width="1280" height="720"></canvas>
	<canvas id="uiLayer" width="1280" height="720" onmousemove="getMousePos(event)" onmousedown="mouseDown(event)" onmouseup="mouseUp(event)"></canvas>
<script src="js/jquery-3.2.1.min.js"></script>
<script src="js/entities.js"></script>
<script src="js/ui.js"></script>
<script>
	
// Canvas
var wCanvas = document.getElementById('worldLayer');
var wCtx = wCanvas.getContext("2d");
var bCanvas = document.getElementById('bgLayer');
var bCtx = bCanvas.getContext("2d");
var pCanvas = document.getElementById('playerLayer');
var pCtx = pCanvas.getContext("2d");
var uCanvas = document.getElementById('uiLayer');
var uCtx = uCanvas.getContext("2d");
console.log("Canvas Created");

// Keys
document.body.addEventListener("keydown", keyDown, false);
document.body.addEventListener("keyup", keyUp, false);

// Create entities
var world = new World();

var player = new Player();

var ui = new UI();

// Database of blocks

// Name
var blockName = ["water", "grass", "sand"];

// Whether they have collision
var blockCollision = [true, false, false];

// Whether blocks have collision for entities
var blockCollisionEntities = [false, false, false];

// Color on map
var blockColor = [
	[255, 255, 255], // water
	[0, 255, 0], // grass
	[255, 255, 0] // sand
];

// Color in world
var blockTextures = [
	[30, 115, 255], // water
	[45, 190, 40], // grass
	[255, 255, 0] // sand
];


window.addEventListener('resize', resize);

function resize(){
	// Get window size
	windowWidth = window.innerWidth || document.body.clientWidth;
	windowHeight =  window.innerHeight || document.body.clientHeight;
	
	// Change canvas size to window size
	wCanvas.width = windowWidth; 
	wCanvas.width = windowWidth;
	bCanvas.width = windowWidth; 
	pCanvas.width = windowWidth;
	uCanvas.width = windowWidth;
	bCanvas.height = windowHeight;
	pCanvas.height = windowHeight;
	uCanvas.height = windowHeight;

	$("body").css("overflow", "hidden");

	// Ensures that world is rendered on the first frame and upon resize
	world.render();
}

// Variables to calculate fps
var fps;
var frame = 0;

// Every second this method is executed. Everytime update() fires frame is incrimented
function calcFps(){
	fps = frame;
	frame = 0;
}

// Find distance given width and height
function findDistance(width, height){
    total = width * width + height * height;
    return Math.sqrt(total);
}

// Get random, min inclusive and max exclusive
function getRandom(min, max) {
  return Math.random() * (max - min) + min;
}

// Happens when page loads
function init(){
	world.create();
	world.transcribe();
	console.log("World Initialized")

	requestAnimationFrame(update);
	console.log("First Refresh");

	//Calculate fps
	setInterval(calcFps, 1000);

	resize();
}

function update(){
	frame += 1;

	world.update();

	//If player is alive, update them
	if (player.alive == true){
		player.update();
	}

	ui.update();

	requestAnimationFrame(update);
}

function World() {
	this.worldWidth = 50;
	this.worldHeight = 50;

	this.blockSize = 40;

	this.blockData = [];

	this.error = [];

	this.entities = [];

	this.islandRadius = 8;

	this.wave = true;
	this.difficulty = 1; 

	// Chooses where entities spawn
	this.spwanCoords = [[0, 0], [0, this.worldHeight], [this.worldWidth, 0], [this.worldWidth, this.worldHeight]];
	this.spawn = 0;

	// Length and width of box where entities can spawn
	this.spawnBounds = 15;

	World.prototype.update = function(){
		pCtx.clearRect(0, 0, windowWidth, windowHeight);
		uCtx.clearRect(0, 0, windowWidth, windowHeight);

		this.spawnEntities();

 		// Assures that world is only rendered when player is moving
 		if (player.movementU != false || player.movementD != false || player.movementL != false || player.movementR != false){
			this.render();
 		}

 		// Updates all entities
 		for (var x = 0; x < this.entities.length; x++){
 			// Only update if entity is alive
 			if (this.entities[x].alive == true){
 				this.entities[x].update();
 			}
 		}
	}

	World.prototype.render = function(){
		// Ensures the screen is only cleared before the canvas updates
		bCtx.clearRect(0, 0, windowWidth, windowHeight);

		// Render world

		// Water background
 		bCtx.fillStyle = "rgb(30, 115, 255)";
 		bCtx.fillRect(0, 0, windowWidth, windowHeight);

 		// Gets coordinates of the top left of the canvas
 		topX = Math.round(player.x - (windowWidth / 2));
 		topY = Math.round(player.y - (windowHeight / 2));

 		// Finds the top left block closest to the top left of the canvas
 		topBlockX = Math.floor(topX / this.blockSize);
 		topBlockY = Math.floor(topY / this.blockSize);

 		// Gets that block's coordinates
 		topBlockCoordX = topBlockX * this.blockSize;
 		topBlockCoordY = topBlockY * this.blockSize;

 		// Finds offset from top left of canvas to the block's coordinates
 		offsetX = topX - topBlockCoordX;
 		offsetY = topY - topBlockCoordY;

 		// Gets the number of blocks in the canvas
 		blockWidth = Math.ceil(windowWidth / this.blockSize) + 1;
 		blockHeight = Math.ceil(windowHeight / this.blockSize) + 1;

 		// Loop through all the blocks that need to be drawn
 		for (var x = 0; x < blockWidth; x++){
 			for (var y = 0; y < blockHeight; y++){

 				// Ensures that blocks not in the array will not be drawn
 				if (topBlockX + x >= 0 && topBlockX + x < this.worldWidth && topBlockY + y >= 0 && topBlockY + y < this.worldWidth){

 					// Ensures that water is not drawn
 					if (this.blockData[topBlockX + x][topBlockY + y] != "water"){

 						//Gets the color of block from its name
	 					colorData = this.getBlockTexture(this.blockData[topBlockX + x][topBlockY + y]);

	 					// Draw block
		 				bCtx.fillStyle = "rgb(" + colorData.r + "," + colorData.g + "," + colorData.b + ")";
		 				bCtx.fillRect(Math.floor(x * this.blockSize - offsetX), Math.floor(y * this.blockSize - offsetY), this.blockSize, this.blockSize);

		 				// Stroke block
		 				bCtx.lineWidth = 2;
		 				bCtx.fillStyle = "black";
		 				bCtx.strokeRect(Math.floor(x * this.blockSize - offsetX), Math.floor(y * this.blockSize - offsetY), this.blockSize, this.blockSize);
		 			}
 				}
 			}
 		}
	}

	World.prototype.spawnEntities = function(){
		// Randomly spawn entities
		random = Math.random() * 100;

		if (random < this.difficulty){
			// Randomly select coordinates at the edges of the map
			coords = this.spwanCoords[this.spawn];
			
			offsetX = getRandom(-this.spawnBounds, this.spawnBounds);
			offsetY = getRandom(-this.spawnBounds, this.spawnBounds);
			
			x = coords[0] + offsetX * world.blockSize;
			y = coords[1] + offsetY * world.blockSize;

			this.entities.push(new Entity(x, y));
		}
	}

	World.prototype.create = function(){
		// Erase current world
		wCtx.fillStyle = "white";
		wCtx.fillRect(0, 0, this.worldWidth, this.worldHeight);

		// Sand background

		// Loops through all the blocks
		for (var x = 0; x < this.worldWidth; x++){
 			for (var y = 0; y < this.worldHeight; y++){
 				// Find center of world
 				centerX = this.worldWidth / 2;
 				centerY = this.worldHeight / 2;

 				// Coord distance from center to current block
 				width = centerX - x;
 				height = centerY - y;

 				// Distance from center to current block
 				distance = findDistance(width, height);

 				// If block is less than island width (plus a little more for the sand to show) draw a block
 				if (distance < this.islandRadius + 1.5){
 					wCtx.fillStyle = 'rgb(255, 255, 0)';
 					wCtx.fillRect(x, y, 1, 1);
 				}
 				
 			}
 		}

 		// Grass background

 		for (var x = 0; x < this.worldWidth; x++){
 			for (var y = 0; y < this.worldHeight; y++){
 				centerX = this.worldWidth / 2;
 				centerY = this.worldHeight / 2;

 				width = centerX - x;
 				height = centerY - y;

 				distance = findDistance(width, height);
 				
 				if (distance < this.islandRadius){
 					wCtx.fillStyle = 'rgb(0, 255, 0)';
 					wCtx.fillRect(x, y, 1, 1);
 				}
 			}
 		}
	}

	World.prototype.transcribe = function(){
		// Transcibes pixels that makeup world onto an array
		for (var x = 0; x < this.worldWidth; x++){

			// Is added onto 2d array
			rowArray = [];

			for (var y = 0; y < this.worldHeight; y++){
				blockType = this.determineBlock(x, y);
				rowArray.push(blockType);
			}

			this.blockData.push(rowArray);
		}
	}

	World.prototype.determineBlock = function(x, y){
		// Determine block name via coordinates through the map

		block = wCtx.getImageData(x, y, 1, 1).data;
		
		// Loops through all the blocks and finds a matching one
		for (var x = 0; x < blockName.length; x++){ 
			if (block[0] == blockColor[x][0] && block[1] == blockColor[x][1] && block[2] == blockColor[x][2]){
				return blockName[x];
			}
		}

		// If block cannot be identified
		return "water";
	}

	World.prototype.determineBlockCollision = function(x, y){
		// Determine collision via coordinates through the world array
		if (x >= 0 && x < this.worldWidth && y >= 0 && y < this.worldWidth){
			block = world.blockData[x][y];

			index = blockName.indexOf(block);

			return blockCollision[index];
		}else{
			// If block is not in array, therefore water
			return true;
		}
	}

	World.prototype.determineEntityBlockCollision = function(x, y){
		// Determine collision for entitiesa via coordinates through the world array
		if (x >= 0 && x < this.worldWidth && y >= 0 && y < this.worldWidth){
			block = world.blockData[x][y];

			index = blockName.indexOf(block);

			return blockCollisionEntities[index];
		}else{
			// If block is not in array, therefore water
			return true;
		}
	}

	World.prototype.getBlockTexture = function(block){
		// Determine block texture via block name

		for (var x = 0; x < blockName.length; x++){
			if (block == blockName[x]){
				return{
					r: blockTextures[x][0],
					g: blockTextures[x][1],
					b: blockTextures[x][2]
				}  
			}
		}
	}
}

function Player(){
	this.health = 100;
	this.alive = true;
	this.maxHealth = 100;

	// Center player on island 
	this.x = world.blockSize * (world.worldWidth / 2);
	this.y = world.blockSize * (world.worldHeight / 2);

	this.screenX;
	this.screenY;

	this.width = 30
	this.height = 30;

	this.movementU = false;
	this.movementD = false;
	this.movementL = false;
	this.movementR = false;

	this.deltaU = 0;
	this.deltaD = 0;
	this.deltaL = 0;
	this.deltaR = 0;

	this.speed = 4;

	this.damage = 10;

	Player.prototype.update = function(){
		// Check if health is too low
		if (this.health <= 0){
			this.alive = false;
		}

		this.movement();
		
		// Draw player
		this.screenX = Math.floor((windowWidth / 2) - (this.width / 2));
		this.screenY = Math.floor((windowHeight / 2) - (this.height / 2));
		
		pCtx.fillStyle = "blue";
		pCtx.fillRect(this.screenX, this.screenY, this.width, this.height);

		pCtx.strokeStyle = "black";
		pCtx.lineWidth = 2;
		pCtx.strokeRect(this.screenX, this.screenY, this.width, this.height);
	}
	Player.prototype.movement = function(){

		// Handles diagonal movement

		this.deltaU = 0;
		this.deltaD = 0;
		this.deltaL = 0;
		this.deltaR = 0;

		if (this.movementU == true){
			if (this.movementL == true){
				this.deltaU = this.speed * 0.75;
				this.deltaL = this.speed * 0.75;
			}else if (this.movementR == true){
				this.deltaU = this.speed * 0.75;
				this.deltaR = this.speed * 0.75;
			}else{
				this.deltaU = this.speed;
			}
		}

		if (this.movementD == true){
			if (this.movementL == true){
				this.deltaD = this.speed * 0.75;
				this.deltaL = this.speed * 0.75;
			}else if (this.movementR == true){
				this.deltaD = this.speed * 0.75;
				this.deltaR = this.speed * 0.75;
			}else{
				this.deltaD = this.speed;
			}
		}

		// No need to cover diagonal movement here since all 4 diagonal directions are already accounted for 
		if (this.movementL == true && this.movementU == false && this.movementD == false){
			this.deltaL = this.speed;
		}

		if (this.movementR == true && this.movementU == false && this.movementD == false){
			this.deltaR = this.speed;
		}

		// Collision detection

		// Gets x and y of top of player
		topX = this.x - (this.width / 2);
		topY = this.y - (this.height / 2);

		// Finds x and y of bottom of player
		bottomX = this.x + (this.width / 2);
		bottomY = this.y + (this.height / 2);

		// Finds how many blocks the player spans in current position
		blockWidth = Math.floor(bottomX / world.blockSize) - Math.floor(topX / world.blockSize) + 1;
		blockHeight = Math.floor(bottomY / world.blockSize) - Math.floor(topY / world.blockSize) + 1;
		
		//If there is a block with collision to the left
		blockL = false

		// Collision left
		// If the player will pass a block next frame
		if (Math.floor(topX / world.blockSize) != Math.floor((topX - this.deltaL) / world.blockSize)){
			// Go through all the blocks adjacent to the player's left
			for (var x = 0; x < blockHeight; x ++){
				blockX = Math.floor((topX - this.deltaL) / world.blockSize);
				blockY = Math.floor(topY / world.blockSize) + x;
				// Find if the block has collision
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockL = true; 
				}
			}
		}

		// Collision right
		blockR = false
		if (Math.floor(bottomX / world.blockSize) != Math.floor((bottomX + this.deltaR) / world.blockSize)){
			for (var x = 0; x < blockHeight; x ++){
				blockX = Math.floor((bottomX + this.deltaR) / world.blockSize);
				blockY = Math.floor(topY / world.blockSize) + x;
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockR = true; 
				}
			}
		}

		// Collision Up
		blockU = false
		if (Math.floor(topY / world.blockSize) != Math.floor((topY - this.deltaU) / world.blockSize)){
			for (var x = 0; x < blockWidth; x ++){
				blockY = Math.floor((topY - this.deltaU) / world.blockSize);
				blockX = Math.floor(topX / world.blockSize) + x;
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockU = true; 
				}
			}
		}

		// Collision Down
		blockD = false
		if (Math.floor(bottomY / world.blockSize) != Math.floor((bottomY + this.deltaD) / world.blockSize)){
			for (var x = 0; x < blockWidth; x ++){
				blockY = Math.floor((bottomY + this.deltaD) / world.blockSize);
				blockX = Math.floor(topX / world.blockSize) + x;
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockD = true; 
				}
			}
		}

		// Collision diagonal

		// Collision top left
		// Only do collision is player is going diagonally (prevents bug)
		if (blockU == false && blockL == false){
			// Check if player will be in a diagonal block next frame
			if (Math.floor(topY / world.blockSize) != Math.floor((topY - this.deltaU) / world.blockSize) && Math.floor(topX / world.blockSize) != Math.floor((topX - this.deltaL) / world.blockSize)){
				// Find that diagonal block
				blockY = Math.floor((topY - this.deltaU) / world.blockSize);
				blockX = Math.floor((topX - this.deltaL) / world.blockSize);
				// Test if that diagonal block has collision
				if (world.determineBlockCollision(blockX, blockY) == true){
					// Ensures player does not come to a complete stop when hitting a block from 
					blockU = true;
				}
			}
		}

		// Collision bottom left
		if (blockD == false && blockL == false){
			if (Math.floor(bottomY / world.blockSize) != Math.floor((bottomY + this.deltaD) / world.blockSize) && Math.floor(topX / world.blockSize) != Math.floor((topX - this.deltaL) / world.blockSize)){
				blockY = Math.floor((bottomY + this.deltaD) / world.blockSize);
				blockX = Math.floor((topX - this.deltaL) / world.blockSize);
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockD = true;
				}
			}
		}

		// Collision bottom right
		if (blockD == false && blockR == false){
			if (Math.floor(bottomY / world.blockSize) != Math.floor((bottomY + this.deltaD) / world.blockSize) && Math.floor(topX / world.blockSize) != Math.floor((bottomX + this.deltaR) / world.blockSize)){
				blockY = Math.floor((bottomY + this.deltaD) / world.blockSize);
				blockX = Math.floor((bottomX + this.deltaR) / world.blockSize);
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockD = true;
				}
			}
		}

		// Collision top right
		if (blockU == false && blockR == false){
			if (Math.floor(bottomY / world.blockSize) != Math.floor((topY - this.deltaU) / world.blockSize) && Math.floor(topX / world.blockSize) != Math.floor((bottomX + this.deltaR) / world.blockSize)){
				blockY = Math.floor((topY - this.deltaU) / world.blockSize);
				blockX = Math.floor((bottomX + this.deltaR) / world.blockSize);
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockU = true;
				}
			}
		}

		// If no block is in the way, change the coordinates

		if (blockR == false){
			this.x += this.deltaR;
		}

		if (blockL == false){
			this.x -= this.deltaL;
		}
		
		if (blockD == false){
			this.y += this.deltaD;
		}
	
		if (blockU == false){
			this.y -= this.deltaU;
		}
	}
}

function keyDown(evt){
  evt.preventDefault();
  set(evt.keyCode);
	evt.stopPropagation();
	return;
}

function keyUp(evt){
  evt.preventDefault();
  unSet(evt.keyCode);
	evt.stopPropagation();
	return;
}

function set(key){
	// W
	if(key == 87){
		player.movementU = true;
	}
	// A
	if(key == 65){
		player.movementL = true;
	}
	// S
	if(key == 83){
		player.movementD = true;
	}
	// D
	if(key == 68){
		player.movementR = true;
	}
}

function unSet(key){
	// W
	if(key == 87){
		player.movementU = false;
	}
	// A
	if(key == 65){
		player.movementL = false;
	}
	// Scontains
	if(key == 83){
		player.movementD = false;
	}
	// D
	if(key == 68){
		player.movementR = false;
	}

	// Causes the world to be rendered at the resting state of movement, which prevents jittery-ness when player moves again
	world.render();
}

// Mouse 

function getMousePos(evt) {
	var rect = bCanvas.getBoundingClientRect();

	ui.mouseX = evt.clientX - rect.left;
	ui.mouseY = evt.clientY - rect.top;

}

// Mouse clicked event listeners

function mouseDown(evt){
	ui.mousePressed = true;
}
function mouseUp(evt){
	ui.mousePressed = false;
	ui.click = true; // Will be true for one frame
}


  
    </script>
  </body>
</html>
