<!DOCTYPE HTML>
<html>
  <head>
    <title>Template</title>
    <style>
      canvas {
		position: absolute;
		top: 0px;
		left: 0px;
	}
    </style>
  </head>
  <body onload="init()">
    <canvas id="worldLayer" width="1280" height="720"></canvas>
    <canvas id="bgLayer" width="1280" height="720"></canvas>
    <canvas id="playerLayer" width="1280" height="720"></canvas>
	<canvas id="uiLayer" width="1280" height="720" onmousemove="getMousePos(event)" onmousedown="mouseDown(event)" onmouseup="mouseUp(event)"></canvas>
<script src="js/jquery-3.2.1.min.js"></script>
<script>
	
// Canvas
var wCanvas = document.getElementById('worldLayer');
var wCtx = wCanvas.getContext("2d");
var bCanvas = document.getElementById('bgLayer');
var bCtx = bCanvas.getContext("2d");
var pCanvas = document.getElementById('playerLayer');
var pCtx = pCanvas.getContext("2d");
var uCanvas = document.getElementById('uiLayer');
var uCtx = uCanvas.getContext("2d");
console.log("Canvas Created");

// Keys
document.body.addEventListener("keydown", keyDown, false);
document.body.addEventListener("keyup", keyUp, false);

// Create entities
var player = new Player();

var world = new World();

var ui = new UI();

// Database of blocks

// Name
var blockName = ["water", "grass", "sand"];

// Whether they have collision
var blockCollision = [true, false, false];

// Color on map
var blockColor = [
	[255, 255, 255], // water
	[0, 255, 0], // grass
	[255, 255, 0] // sand
];

// Color in world
var blockTextures = [
	[30, 115, 255], // water
	[45, 190, 40], // grass
	[255, 255, 0] // sand
];


window.addEventListener('resize', resize);

function resize(){
	// Get window size
	windowWidth = window.innerWidth || document.body.clientWidth;
	windowHeight =  window.innerHeight || document.body.clientHeight;
	
	// Change canvas size to window size
	wCanvas.width = windowWidth; 
	wCanvas.width = windowWidth;
	bCanvas.width = windowWidth; 
	pCanvas.width = windowWidth;
	uCanvas.width = windowWidth;
	bCanvas.height = windowHeight;
	pCanvas.height = windowHeight;
	uCanvas.height = windowHeight;

	$("body").css("overflow", "hidden");

	// Ensures that world is rendered on the first frame and upon resize
	world.render();
}

// Happens when page loads
function init(){
	world.create();
	world.transcribe();
	console.log("World Initialized")

	requestAnimationFrame(update);
	console.log("First Refresh");

	//Calculate fps
	setInterval(calcFps, 1000);

	resize();
}

function update(){
	frame += 1;


	world.update();
	player.update();
	ui.update();


	requestAnimationFrame(update);
}

// Variables to calculate fps
var fps;
var frame = 0;

// Every second this method is executed. Everytime update() fires frame is incrimented
function calcFps(){
	fps = frame;
	frame = 0;
}

function World() {
	this.worldWidth = 30;
	this.worldHeight = 30;

	this.blockSize = 40;

	this.blockData = [];

	this.error = [];

	World.prototype.update = function(){
 		// Assures that world is only rendered when player is moving
 		if (player.movementU != false || player.movementD != false || player.movementL != false || player.movementR != false){
			this.render();
 		}
	}

	World.prototype.render = function(){
		// Ensures the screen is only cleared before the canvas updates
		bCtx.clearRect(0, 0, windowWidth, windowHeight);

		// Render world

		// Water background
 		bCtx.fillStyle = "rgb(30, 115, 255)";
 		bCtx.fillRect(0, 0, windowWidth, windowHeight);

 		// Gets coordinates of the top left of the canvas
 		topX = Math.round(player.x - (windowWidth / 2));
 		topY = Math.round(player.y - (windowHeight / 2));

 		// Finds the top left block closest to the top left of the canvas
 		topBlockX = Math.floor(topX / this.blockSize);
 		topBlockY = Math.floor(topY / this.blockSize);

 		// Gets that block's coordinates
 		topBlockCoordX = topBlockX * this.blockSize;
 		topBlockCoordY = topBlockY * this.blockSize;

 		// Finds offset from top left of canvas to the block's coordinates
 		offsetX = topX - topBlockCoordX;
 		offsetY = topY - topBlockCoordY;

 		// Gets the number of blocks in the canvas
 		blockWidth = Math.ceil(windowWidth / this.blockSize) + 1;
 		blockHeight = Math.ceil(windowHeight / this.blockSize) + 1;

 		// Loop thought all the blocks that need to be drawn
 		for (var x = 0; x < blockWidth; x++){
 			for (var y = 0; y < blockHeight; y++){

 				// Ensures that blocks not in the array will not be drawn
 				if (topBlockX + x >= 0 && topBlockX + x < this.worldWidth && topBlockY + y >= 0 && topBlockY + y < this.worldWidth){

 					// Ensures that water is not drawn
 					if (this.blockData[topBlockX + x][topBlockY + y] != "water"){

 						//Gets the color of block from its name
	 					colorData = this.getBlockTexture(this.blockData[topBlockX + x][topBlockY + y]);

	 					// Draw block
		 				bCtx.fillStyle = "rgb(" + colorData.r + "," + colorData.g + "," + colorData.b + ")";
		 				bCtx.fillRect(Math.floor(x * this.blockSize - offsetX), Math.floor(y * this.blockSize - offsetY), this.blockSize, this.blockSize);

		 				// Stroke block
		 				bCtx.lineWidth = 2;
		 				bCtx.fillStyle = "black";
		 				bCtx.strokeRect(Math.floor(x * this.blockSize - offsetX), Math.floor(y * this.blockSize - offsetY), this.blockSize, this.blockSize);
		 			}
 				}
 			}
 		}

	}

	World.prototype.create = function(){
		// Erase current world
		wCtx.fillStyle = "white";
		wCtx.fillRect(0, 0, this.worldWidth, this.worldHeight);

	    // Make new world
		wCtx.beginPath();
	    wCtx.arc(15, 15, 10, 0, 2 * Math.PI, false);
	    wCtx.fillStyle = 'rgb(0, 255, 0)';
	    wCtx.fill();

	    // Make new world
		wCtx.fillStyle = "rgb(255, 255, 0)";
		wCtx.fillRect(22, 10, 2, 10);

	    wCtx.fillStyle = "white";
	    wCtx.fillRect(9, 11, 1, 8);
	    wCtx.fillRect(11, 9, 8, 1);

	    wCtx.fillRect(18, 18, 1, 1);
	    wCtx.fillRect(19, 19, 1, 1);
	    wCtx.fillRect(20, 20, 1, 1);

	    wCtx.fillRect(15, 18, 1, 1);
	    wCtx.fillRect(14, 19, 1, 1);
	    wCtx.fillRect(13, 20, 1, 1);
		
	}

	World.prototype.transcribe = function(){
		// Transcibes pixels that makeup world onto an array
		for (var x = 0; x < this.worldWidth; x++){

			// Is added onto 2d array
			rowArray = [];

			for (var y = 0; y < this.worldHeight; y++){
				blockType = this.determineBlock(x, y);
				rowArray.push(blockType);
			}

			this.blockData.push(rowArray);
		}
	}

	World.prototype.determineBlock = function(x, y){
		// Determine block name via coordinates through the map

		block = wCtx.getImageData(x, y, 1, 1).data;
		
		// Loops through all the blocks and finds a matching one
		for (var x = 0; x < blockName.length; x++){ 
			if (block[0] == blockColor[x][0] && block[1] == blockColor[x][1] && block[2] == blockColor[x][2]){
				return blockName[x];
			}
		}

		// If block cannot be identified
		return "water";
	}

	World.prototype.determineBlockCollision = function(x, y){
		// Determine collision  via coordinates through the world array
		if (x >= 0 && x < this.worldWidth && y >= 0 && y < this.worldWidth){
			block = world.blockData[x][y];

			index = blockName.indexOf(block);

			return blockCollision[index];
		}else{
			// If block is not in array, therefore water
			return true;
		}
	}

	World.prototype.getBlockTexture = function(block){
		// Determine block texture via block name

		for (var x = 0; x < blockName.length; x++){
			if (block == blockName[x]){
				return{
					r: blockTextures[x][0],
					g: blockTextures[x][1],
					b: blockTextures[x][2]
				}  
			}
		}
	}
}

function Player(){
	this.x = 600;
	this.y = 600;

	this.screenX;
	this.screenY;

	this.width = 30
	this.height = 30;

	this.movementU = false;
	this.movementD = false;
	this.movementL = false;
	this.movementR = false;

	this.deltaU = 0;
	this.deltaD = 0;
	this.deltaL = 0;
	this.deltaR = 0;

	this.speed = 4;

	Player.prototype.update = function(){
		pCtx.clearRect(0, 0, windowWidth, windowHeight);

		this.movement();
		
		// Draw player
		this.screenX = Math.floor((windowWidth / 2) - (this.width / 2));
		this.screenY = Math.floor((windowHeight / 2) - (this.height / 2));
		
		pCtx.fillStyle = "red";
		pCtx.fillRect(this.screenX, this.screenY, this.width, this.height);

		pCtx.strokeStyle = "black";
		pCtx.lineWidth = 2;
		pCtx.strokeRect(this.screenX, this.screenY, this.width, this.height);
	}
	Player.prototype.movement = function(){

		// Handles diagonal movement

		this.deltaU = 0;
		this.deltaD = 0;
		this.deltaL = 0;
		this.deltaR = 0;

		if (this.movementU == true){
			if (this.movementL == true){
				this.deltaU = this.speed * 0.75;
				this.deltaL = this.speed * 0.75;
			}else if (this.movementR == true){
				this.deltaU = this.speed * 0.75;
				this.deltaR = this.speed * 0.75;
			}else{
				this.deltaU = this.speed;
			}
		}

		if (this.movementD == true){
			if (this.movementL == true){
				this.deltaD = this.speed * 0.75;
				this.deltaL = this.speed * 0.75;
			}else if (this.movementR == true){
				this.deltaD = this.speed * 0.75;
				this.deltaR = this.speed * 0.75;
			}else{
				this.deltaD = this.speed;
			}
		}

		// No need to cover diagonal movement here since all 4 diagonal directions are already accounted for 
		if (this.movementL == true && this.movementU == false && this.movementD == false){
			this.deltaL = this.speed;
		}

		if (this.movementR == true && this.movementU == false && this.movementD == false){
			this.deltaR = this.speed;
		}

		// Collision detection

		// Gets x and y of top of player
		topX = this.x - (this.width / 2);
		topY = this.y - (this.height / 2);

		// Finds x and y of bottom of player
		bottomX = this.x + (this.width / 2);
		bottomY = this.y + (this.height / 2);

		// Finds how many blocks the player spans in current position
		blockWidth = Math.floor(bottomX / world.blockSize) - Math.floor(topX / world.blockSize) + 1;
		blockHeight = Math.floor(bottomY / world.blockSize) - Math.floor(topY / world.blockSize) + 1;

		
		//If there is a block with collision to the left
		blockL = false

		// If the player will pass a block next frame
		if (Math.floor(topX / world.blockSize) != Math.floor((topX - this.deltaL) / world.blockSize)){
			// Go through all the blocks adjacent to the player's left
			for (var x = 0; x < blockHeight; x ++){
				blockX = Math.floor((topX - this.deltaL) / world.blockSize);
				blockY = Math.floor(topY / world.blockSize) + x;
				// Find if the block has collision
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockL = true; 
				}
			}
		}

		blockR = false
		if (Math.floor(bottomX / world.blockSize) != Math.floor((bottomX + this.deltaR) / world.blockSize)){
			for (var x = 0; x < blockHeight; x ++){
				blockX = Math.floor((bottomX + this.deltaR) / world.blockSize);
				blockY = Math.floor(topY / world.blockSize) + x;
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockR = true; 
				}
			}
		}

		blockU = false
		if (Math.floor(topY / world.blockSize) != Math.floor((topY - this.deltaU) / world.blockSize)){
			for (var x = 0; x < blockWidth; x ++){
				blockY = Math.floor((topY - this.deltaU) / world.blockSize);
				blockX = Math.floor(topX / world.blockSize) + x;
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockU = true; 
				}
			}
		}

		blockD = false
		if (Math.floor(bottomY / world.blockSize) != Math.floor((bottomY + this.deltaD) / world.blockSize)){
			for (var x = 0; x < blockWidth; x ++){
				blockY = Math.floor((bottomY + this.deltaD) / world.blockSize);
				blockX = Math.floor(topX / world.blockSize) + x;
				if (world.determineBlockCollision(blockX, blockY) == true){
					blockD = true; 
				}
			}
		}

		// If no block is in the way, change the coordinates

		if (blockR == false){
			this.x += this.deltaR;
		}

		if (blockL == false){
			this.x -= this.deltaL;
		}
		
		if (blockD == false){
			this.y += this.deltaD;
		}
	
		if (blockU == false){
			this.y -= this.deltaU;
		}
	}
}

function UI(){
	this.mouseX;
	this.mouseY;
	this.mousePressed = false;
	this.click = false;

	this.map = false;
	UI.prototype.update = function(){
		uCtx.clearRect(0, 0, windowWidth, windowHeight);

		this.debugMenu();

		this.click = false; // True for one frame after player releases mouse
	}

	UI.prototype.debugMenu = function(){
		uCtx.fillStyle = "black";
		uCtx.font = "16px Arial";

		uCtx.fillText("FPS " + fps, 5, 20);
		uCtx.fillText("X " + player.x + ", " + Math.floor(player.x / world.blockSize), 5, 40);
		uCtx.fillText("Y " + player.y + ", " + Math.floor(player.y / world.blockSize), 5, 60);

	}
}


function keyDown(evt){
  evt.preventDefault();
  set(evt.keyCode);
	evt.stopPropagation();
	return;
}

function keyUp(evt){
  evt.preventDefault();
  unSet(evt.keyCode);
	evt.stopPropagation();
	return;
}

function set(key){
	// W
	if(key == 87){
		player.movementU = true;
	}
	// A
	if(key == 65){
		player.movementL = true;
	}
	// S
	if(key == 83){
		player.movementD = true;
	}
	// D
	if(key == 68){
		player.movementR = true;
	}
}

function unSet(key){
	// W
	if(key == 87){
		player.movementU = false;
	}
	// A
	if(key == 65){
		player.movementL = false;
	}
	// S
	if(key == 83){
		player.movementD = false;
	}
	// D
	if(key == 68){
		player.movementR = false;
	}

	// Causes the world to be rendered at the resting state of movement, which prevents jittery-ness when player moves again
	world.render();
}

// Mouse 

function getMousePos(evt) {
	var rect = bCanvas.getBoundingClientRect();

	ui.mouseX = evt.clientX - rect.left;
	ui.mouseY = evt.clientY - rect.top;

}

// Mouse clicked event listeners

function mouseDown(evt){
	ui.mousePressed = true;
}
function mouseUp(evt){
	ui.mousePressed = false;
	ui.click = true; // Will be true for one frame
}


  
    </script>
  </body>
</html>
